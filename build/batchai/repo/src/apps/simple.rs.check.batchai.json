{
    "has_issue": false,
    "overall_severity": "",
    "issues": [],
    "fixed_code": "use std::collections::BTreeMap;\nuse std::sync::Arc;\n\nuse anyhow::{anyhow, Result};\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::base::*;\nuse crate::util;\nuse crate::AppT;\nuse crate::ConsoleSender;\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", deny_unknown_fields)]\nstruct Message {\n    #[serde(skip)]\n    id: String,\n\n    template: String,\n    file: String,\n    line: usize,\n    method: String,\n\n    #[serde(default)]\n    level: Level,\n}\n\nimpl Message {\n    fn init(\u0026mut self, id: String, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        self.id = id;\n        self.with_template(tmpl)\n    }\n\n    fn with_template(\u0026self, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        tmpl.add_template(\u0026self.id, \u0026self.template)\n    }\n\n    fn populate(\u0026self, t: \u0026mut Template) -\u003e Result\u003c()\u003e {\n        t.set(\"file\", \u0026self.file);\n        t.set(\"line\", \u0026self.line);\n        t.set(\"method\", \u0026self.method);\n        t.set(\"level\", self.level.name());\n\n        let msg_text = t.render(\u0026self.id)?;\n        t.set(\"message\", \u0026msg_text);\n\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", deny_unknown_fields)]\npub struct Logger {\n    #[serde(skip)]\n    id: String,\n\n    name: String,\n    message: Vec\u003cMessage\u003e,\n}\n\nimpl Logger {\n    fn init(\u0026mut self, id: String, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        self.id = id;\n        self.init_message(tmpl)\n    }\n\n    fn init_message(\u0026mut self, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        if self.message.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 message\",\n                self.name\n            ));\n        }\n\n        for (i, message_d) in self.message.iter_mut().enumerate() {\n            let msg_id = format!(\"{}/{}\", self.id, i);\n            message_d.init(msg_id, tmpl)?;\n        }\n\n        return Ok(());\n    }\n\n    fn choose_message(\u0026self) -\u003e \u0026Message {\n        util::rand::choose_arr(\u0026self.message)\n    }\n\n    fn populate(\u0026self, t: \u0026mut Template) -\u003e Result\u003c()\u003e {\n        t.set(\"logger\", \u0026self.name);\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct App {\n    #[serde(skip)]\n    name: String,\n\n    #[serde(skip, default)]\n    template_engine: TemplateEngine,\n\n    #[serde(default)]\n    output: Output,\n\n    //#[serde(flatten)]\n    #[serde(default)]\n    mdc: BTreeMap\u003cString, Value\u003e,\n\n    num_of_lines: u64,\n    begin_time: DateTime\u003cUtc\u003e, //rfc3339\n    end_time: DateTime\u003cUtc\u003e,\n    host: Vec\u003cString\u003e,\n    logger: Vec\u003cLogger\u003e,\n}\n\n#[typetag::serde(name = \"simple\")]\nimpl AppT for App {\n    fn init(\u0026mut self, name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.name = name.to_string();\n        self.output.init(\u0026self.name, \u0026mut self.template_engine)?;\n        self.init_logger()\n    }\n\n    fn generate(\u0026self, console: ConsoleSender) -\u003e Result\u003c()\u003e {\n        let mut appenders = self.output.build_appenders(\u0026console)?;\n        let f = self.output.build_formatter();\n        let mut ts = Timestamp::new(\u0026self.begin_time, \u0026self.end_time, self.num_of_lines);\n\n        for i in 0..self.num_of_lines {\n            let timetamp = ts.inc();\n\n            let t = \u0026mut self.new_template(i);\n            t.set(\"timestamp\", \u0026f.format_timestamp(\u0026timetamp));\n\n            let logger = self.choose_logger();\n            logger.populate(t)?;\n            logger.choose_message().populate(t)?;\n\n            for appender in \u0026mut appenders {\n                let line = Arc::new(Line {\n                    name: self.name.to_string(),\n                    timestamp: *timetamp,\n                    text: f.format(t, \u0026self.name)?,\n                });\n                appender.append(\u0026line)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn need_console(\u0026self) -\u003e bool {\n        self.output.need_console()\n    }\n}\n\nimpl App {\n    fn init_logger(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.host.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 host\",\n                self.name\n            ));\n        }\n\n        if self.logger.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 logger\",\n                self.name\n            ));\n        }\n\n        for (i, logger) in self.logger.iter_mut().enumerate() {\n            let logger_id = format!(\"{}/{}\", self.name, i);\n            logger.init(logger_id, \u0026mut self.template_engine)?;\n        }\n\n        return Ok(());\n    }\n\n    fn choose_host(\u0026self) -\u003e \u0026str {\n        \u0026util::rand::choose_arr(\u0026self.host)\n    }\n\n    fn choose_logger(\u0026self) -\u003e \u0026Logger {\n        util::rand::choose_arr(\u0026self.logger)\n    }\n\n    fn new_template\u003c'a\u003e(\u0026'a self, index: u64) -\u003e Template {\n        let mut r = Template::new(\u0026\u0026self.template_engine);\n\n        r.set(\"app\", \u0026self.name);\n        r.set(\"index\", \u0026index);\n        r.set(\"host\", self.choose_host());\n        r.set(\"pid\", \u0026rand::thread_rng().gen::\u003cu16\u003e());\n        r.set(\"mdc\", \u0026self.mdc);\n\n        r\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_url_works() {\n        let f = serde_yaml::from_str::\u003cOutput\u003e(r#\"\n            flat:\n                timestamp_format: \"%Y-%m-%d %H:%M:%S\"\n                template: '{{timestamp}} \u003c{{level | upper | align_left(width=5)}}\u003e {{logger.name}} {{file}}/{{line}} {{method}} - {{message}}'\n            json:\n                style: bunyan\"#).unwrap();\n        //assert!(f.\"abc\".is_err());\n    }\n}\n",
    "original_code": "use std::collections::BTreeMap;\nuse std::sync::Arc;\n\nuse anyhow::{anyhow, Result};\nuse chrono::{DateTime, Utc};\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse serde_json::Value;\n\nuse crate::base::*;\nuse crate::util;\nuse crate::AppT;\nuse crate::ConsoleSender;\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", deny_unknown_fields)]\nstruct Message {\n    #[serde(skip)]\n    id: String,\n\n    template: String,\n    file: String,\n    line: usize,\n    method: String,\n\n    #[serde(default)]\n    level: Level,\n}\n\nimpl Message {\n    fn init(\u0026mut self, id: String, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        self.id = id;\n        self.with_template(tmpl)\n    }\n\n    fn with_template(\u0026self, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        tmpl.add_template(\u0026self.id, \u0026self.template)\n    }\n\n    fn populate(\u0026self, t: \u0026mut Template) -\u003e Result\u003c()\u003e {\n        t.set(\"file\", \u0026self.file);\n        t.set(\"line\", \u0026self.line);\n        t.set(\"method\", \u0026self.method);\n        t.set(\"level\", self.level.name());\n\n        let msg_text = t.render(\u0026self.id)?;\n        t.set(\"message\", \u0026msg_text);\n\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\", deny_unknown_fields)]\npub struct Logger {\n    #[serde(skip)]\n    id: String,\n\n    name: String,\n    message: Vec\u003cMessage\u003e,\n}\n\nimpl Logger {\n    fn init(\u0026mut self, id: String, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        self.id = id;\n        self.init_message(tmpl)\n    }\n\n    fn init_message(\u0026mut self, tmpl: \u0026mut TemplateEngine) -\u003e Result\u003c()\u003e {\n        if self.message.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 message\",\n                self.name\n            ));\n        }\n\n        for (i, message_d) in self.message.iter_mut().enumerate() {\n            let msg_id = format!(\"{}/{}\", self.id, i);\n            message_d.init(msg_id, tmpl)?;\n        }\n\n        return Ok(());\n    }\n\n    fn choose_message(\u0026self) -\u003e \u0026Message {\n        util::rand::choose_arr(\u0026self.message)\n    }\n\n    fn populate(\u0026self, t: \u0026mut Template) -\u003e Result\u003c()\u003e {\n        t.set(\"logger\", \u0026self.name);\n        Ok(())\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub struct App {\n    #[serde(skip)]\n    name: String,\n\n    #[serde(skip, default)]\n    template_engine: TemplateEngine,\n\n    #[serde(default)]\n    output: Output,\n\n    //#[serde(flatten)]\n    #[serde(default)]\n    mdc: BTreeMap\u003cString, Value\u003e,\n\n    num_of_lines: u64,\n    begin_time: DateTime\u003cUtc\u003e, //rfc3339\n    end_time: DateTime\u003cUtc\u003e,\n    host: Vec\u003cString\u003e,\n    logger: Vec\u003cLogger\u003e,\n}\n\n#[typetag::serde(name = \"simple\")]\nimpl AppT for App {\n    fn init(\u0026mut self, name: \u0026str) -\u003e Result\u003c()\u003e {\n        self.name = name.to_string();\n        self.output.init(\u0026self.name, \u0026mut self.template_engine)?;\n        self.init_logger()\n    }\n\n    fn generate(\u0026self, console: ConsoleSender) -\u003e Result\u003c()\u003e {\n        let mut appenders = self.output.build_appenders(\u0026console)?;\n        let f = self.output.build_formatter();\n        let mut ts = Timestamp::new(\u0026self.begin_time, \u0026self.end_time, self.num_of_lines);\n\n        for i in 0..self.num_of_lines {\n            let timetamp = ts.inc();\n\n            let t = \u0026mut self.new_template(i);\n            t.set(\"timestamp\", \u0026f.format_timestamp(\u0026timetamp));\n\n            let logger = self.choose_logger();\n            logger.populate(t)?;\n            logger.choose_message().populate(t)?;\n\n            for appender in \u0026mut appenders {\n                let line = Arc::new(Line {\n                    name: self.name.to_string(),\n                    timestamp: *timetamp,\n                    text: f.format(t, \u0026self.name)?,\n                });\n                appender.append(\u0026line)?;\n            }\n        }\n\n        Ok(())\n    }\n\n    fn need_console(\u0026self) -\u003e bool {\n        self.output.need_console()\n    }\n}\n\nimpl App {\n    fn init_logger(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.host.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 host\",\n                self.name\n            ));\n        }\n\n        if self.logger.len() == 0 {\n            return Err(anyhow!(\n                \"app {} should configure at least 1 logger\",\n                self.name\n            ));\n        }\n\n        for (i, logger) in self.logger.iter_mut().enumerate() {\n            let logger_id = format!(\"{}/{}\", self.name, i);\n            logger.init(logger_id, \u0026mut self.template_engine)?;\n        }\n\n        return Ok(());\n    }\n\n    fn choose_host(\u0026self) -\u003e \u0026str {\n        \u0026util::rand::choose_arr(\u0026self.host)\n    }\n\n    fn choose_logger(\u0026self) -\u003e \u0026Logger {\n        util::rand::choose_arr(\u0026self.logger)\n    }\n\n    fn new_template\u003c'a\u003e(\u0026'a self, index: u64) -\u003e Template {\n        let mut r = Template::new(\u0026\u0026self.template_engine);\n\n        r.set(\"app\", \u0026self.name);\n        r.set(\"index\", \u0026index);\n        r.set(\"host\", self.choose_host());\n        r.set(\"pid\", \u0026rand::thread_rng().gen::\u003cu16\u003e());\n        r.set(\"mdc\", \u0026self.mdc);\n\n        r\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn parse_url_works() {\n        let f = serde_yaml::from_str::\u003cOutput\u003e(r#\"\n            flat:\n                timestamp_format: \"%Y-%m-%d %H:%M:%S\"\n                template: '{{timestamp}} \u003c{{level | upper | align_left(width=5)}}\u003e {{logger.name}} {{file}}/{{line}} {{method}} - {{message}}'\n            json:\n                style: bunyan\"#).unwrap();\n        //assert!(f.\"abc\".is_err());\n    }\n}\n",
    "path": "src/apps/simple.rs",
    "model_usage_metrics": {
        "Duration": 1170769950,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    }
}