{
    "path": "src/base/tpl.rs",
    "model_usage_metrics": {
        "Duration": 11151755617,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "src/base/tpl.rs",
    "existing_test_code": "",
    "original_code": "use crate::util::teras;\nuse anyhow::{Context, Result};\nuse serde::Serialize;\nuse tera::{to_value, Tera, Value};\n\npub const KEY_LEVEL: \u0026str = \"level\";\n\n#[derive(Debug)]\npub struct Engine {\n    tera: Tera,\n}\n\nimpl Engine {\n    pub fn new() -\u003e Self {\n        Self {\n            tera: teras::default(),\n        }\n    }\n\n    pub fn add_template(\u0026mut self, template_name: \u0026str, content: \u0026str) -\u003e Result\u003c()\u003e {\n        self.tera\n            .add_raw_template(template_name, content)\n            .with_context(|| format!(\"failed to add template '{}': {}\", template_name, content))\n    }\n\n    pub fn render(\u0026self, template_name: \u0026str, data: \u0026tera::Context) -\u003e Result\u003cString\u003e {\n        self.tera\n            .render(template_name, data)\n            .with_context(|| format!(\"failed to render template '{}': {:?}\", template_name, data))\n    }\n}\n\nimpl Default for Engine {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\npub struct Template\u003c'a\u003e {\n    data: tera::Context,\n    engine: \u0026'a Engine,\n}\n\nimpl\u003c'a\u003e Template\u003c'a\u003e {\n    pub fn new(engine: \u0026'a Engine) -\u003e Self {\n        Self {\n            data: tera::Context::new(),\n            engine,\n        }\n    }\n\n    pub fn set\u003cT: Serialize + ?Sized\u003e(\u0026mut self, key: \u0026str, val: \u0026T) {\n        self.data.insert(key, \u0026to_value(val).unwrap())\n    }\n\n    pub fn get(\u0026self, key: \u0026str) -\u003e Option\u003c\u0026Value\u003e {\n        self.data.get(key)\n    }\n\n    pub fn into_json(self) -\u003e Value {\n        self.data.into_json()\n    }\n\n    pub fn render(\u0026self, template_name: \u0026str) -\u003e Result\u003cString\u003e {\n        self.engine.render(template_name, \u0026self.data)\n    }\n}\n",
    "test_code": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use tera::Context;\n\n    /// Test cases for the Engine and Template structs.\n    /// This includes tests for adding templates, rendering templates,\n    /// setting and getting values in the context, and handling errors.\n    #[test]\n    fn test_engine_add_template_success() {\n        // Step 1: Create a new Engine instance\n        let mut engine = Engine::new();\n        // Step 2: Add a template successfully\n        let result = engine.add_template(\"test_template\", \"Hello, {{ name }}!\");\n        // Step 3: Assert that the result is Ok\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_engine_render_success() {\n        // Step 1: Create a new Engine instance and add a template\n        let mut engine = Engine::new();\n        engine.add_template(\"greeting\", \"Hello, {{ name }}!\").unwrap();\n        // Step 2: Create a context with data\n        let mut context = Context::new();\n        context.insert(\"name\", \"Alice\");\n        // Step 3: Render the template\n        let result = engine.render(\"greeting\", \u0026context);\n        // Step 4: Assert that the rendered result is as expected\n        assert_eq!(result.unwrap(), \"Hello, Alice!\");\n    }\n\n    #[test]\n    fn test_engine_render_template_not_found() {\n        // Step 1: Create a new Engine instance\n        let engine = Engine::new();\n        // Step 2: Create a context with data\n        let context = Context::new();\n        // Step 3: Attempt to render a non-existent template\n        let result = engine.render(\"non_existent_template\", \u0026context);\n        // Step 4: Assert that the result is an error\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_template_set_and_get() {\n        // Step 1: Create a new Engine instance\n        let engine = Engine::new();\n        // Step 2: Create a new Template instance\n        let mut template = Template::new(\u0026engine);\n        // Step 3: Set a value in the template context\n        template.set(\"name\", \"Bob\");\n        // Step 4: Get the value from the template context\n        let value = template.get(\"name\").unwrap();\n        // Step 5: Assert that the value is as expected\n        assert_eq!(value.as_str().unwrap(), \"Bob\");\n    }\n\n    #[test]\n    fn test_template_render_with_no_data() {\n        // Step 1: Create a new Engine instance and add a template\n        let mut engine = Engine::new();\n        engine.add_template(\"empty_template\", \"No data here.\").unwrap();\n        // Step 2: Create a new Template instance\n        let template = Template::new(\u0026engine);\n        // Step 3: Render the template without any data\n        let result = template.render(\"empty_template\");\n        // Step 4: Assert that the rendered result is as expected\n        assert_eq!(result.unwrap(), \"No data here.\");\n    }\n\n    #[test]\n    fn test_template_render_with_missing_key() {\n        // Step 1: Create a new Engine instance and add a template\n        let mut engine = Engine::new();\n        engine.add_template(\"greeting\", \"Hello, {{ name }}!\").unwrap();\n        // Step 2: Create a context without the 'name' key\n        let context = Context::new();\n        // Step 3: Attempt to render the template\n        let result = engine.render(\"greeting\", \u0026context);\n        // Step 4: Assert that the result is an error\n        assert!(result.is_err());\n    }\n}\n",
    "amount_of_generated_test_cases": 6,
    "single_test_run_command": "cargo test"
}