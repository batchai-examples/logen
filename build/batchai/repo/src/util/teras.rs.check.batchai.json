{
    "has_issue": false,
    "overall_severity": "",
    "issues": [],
    "fixed_code": "use std::collections::{BTreeMap, HashMap};\n\nuse tera::{to_value, try_get_value, Tera, Value};\n\nuse super::text;\n\npub fn default() -\u003e Tera {\n    let mut tera = Tera::default();\n\n    // disable autoescaping completely\n    tera.autoescape_on(vec![]);\n\n    register_default_filters(\u0026mut tera);\n\n    return tera;\n}\n\npub fn register_default_filters(tera: \u0026mut Tera) {\n    tera.register_filter(\"map\", filter_map);\n    tera.register_filter(\"align_left\", filter_align_left);\n    tera.register_filter(\"align_right\", filter_align_right);\n}\n\nfn filter_map(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"map\", \"value\", BTreeMap\u003cString,Value\u003e, value);\n\n    let mut sep = match args.get(\"sep\") {\n        Some(sep) =\u003e try_get_value!(\"map\", \"sep\", String, sep),\n        None =\u003e \"=\".to_string(),\n    };\n    if sep.len() == 0 {\n        sep = \"=\".to_string();\n    }\n\n    let mut delimit = match args.get(\"delimit\") {\n        Some(delimit) =\u003e try_get_value!(\"map\", \"delimit\", String, delimit),\n        None =\u003e \",\".to_string(),\n    };\n    if delimit.len() == 0 {\n        delimit = \",\".to_string();\n    }\n\n    let mut r = String::with_capacity(value.len() * 64);\n    let mut first = true;\n    for (k, v) in value.iter() {\n        if first {\n            first = false;\n        } else {\n            r.push_str(\u0026delimit);\n        }\n\n        r.push_str(k);\n        r.push_str(\u0026sep);\n        r.push_str(\u0026v.to_string());\n    }\n    return Ok(to_value(r).unwrap());\n}\n\nfn filter_align_left(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"align_left\", \"value\", String, value);\n\n    let width = match args.get(\"width\") {\n        Some(width) =\u003e try_get_value!(\"align_left\", \"width\", usize, width),\n        None =\u003e {\n            return Err(tera::Error::msg(\n                \"filter `align_left` expected an arg called `width`\",\n            ))\n        }\n    };\n\n    let r = text::align_left(\u0026value, width);\n    return Ok(to_value(r).unwrap());\n}\n\nfn filter_align_right(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"align_right\", \"value\", String, value);\n\n    let width = match args.get(\"width\") {\n        Some(width) =\u003e try_get_value!(\"align_right\", \"width\", usize, width),\n        None =\u003e {\n            return Err(tera::Error::msg(\n                \"filter `align_right` expected an arg called `width`\",\n            ))\n        }\n    };\n\n    let r = text::align_right(\u0026value, width);\n    return Ok(to_value(r).unwrap());\n}\n",
    "original_code": "use std::collections::{BTreeMap, HashMap};\n\nuse tera::{to_value, try_get_value, Tera, Value};\n\nuse super::text;\n\npub fn default() -\u003e Tera {\n    let mut tera = Tera::default();\n\n    // disable autoescaping completely\n    tera.autoescape_on(vec![]);\n\n    register_default_filters(\u0026mut tera);\n\n    return tera;\n}\n\npub fn register_default_filters(tera: \u0026mut Tera) {\n    tera.register_filter(\"map\", filter_map);\n    tera.register_filter(\"align_left\", filter_align_left);\n    tera.register_filter(\"align_right\", filter_align_right);\n}\n\nfn filter_map(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"map\", \"value\", BTreeMap\u003cString,Value\u003e, value);\n\n    let mut sep = match args.get(\"sep\") {\n        Some(sep) =\u003e try_get_value!(\"map\", \"sep\", String, sep),\n        None =\u003e \"=\".to_string(),\n    };\n    if sep.len() == 0 {\n        sep = \"=\".to_string();\n    }\n\n    let mut delimit = match args.get(\"delimit\") {\n        Some(delimit) =\u003e try_get_value!(\"map\", \"delimit\", String, delimit),\n        None =\u003e \",\".to_string(),\n    };\n    if delimit.len() == 0 {\n        delimit = \",\".to_string();\n    }\n\n    let mut r = String::with_capacity(value.len() * 64);\n    let mut first = true;\n    for (k, v) in value.iter() {\n        if first {\n            first = false;\n        } else {\n            r.push_str(\u0026delimit);\n        }\n\n        r.push_str(k);\n        r.push_str(\u0026sep);\n        r.push_str(\u0026v.to_string());\n    }\n    return Ok(to_value(r).unwrap());\n}\n\nfn filter_align_left(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"align_left\", \"value\", String, value);\n\n    let width = match args.get(\"width\") {\n        Some(width) =\u003e try_get_value!(\"align_left\", \"width\", usize, width),\n        None =\u003e {\n            return Err(tera::Error::msg(\n                \"filter `align_left` expected an arg called `width`\",\n            ))\n        }\n    };\n\n    let r = text::align_left(\u0026value, width);\n    return Ok(to_value(r).unwrap());\n}\n\nfn filter_align_right(value: \u0026Value, args: \u0026HashMap\u003cString, Value\u003e) -\u003e tera::Result\u003cValue\u003e {\n    let value = try_get_value!(\"align_right\", \"value\", String, value);\n\n    let width = match args.get(\"width\") {\n        Some(width) =\u003e try_get_value!(\"align_right\", \"width\", usize, width),\n        None =\u003e {\n            return Err(tera::Error::msg(\n                \"filter `align_right` expected an arg called `width`\",\n            ))\n        }\n    };\n\n    let r = text::align_right(\u0026value, width);\n    return Ok(to_value(r).unwrap());\n}\n",
    "path": "src/util/teras.rs",
    "model_usage_metrics": {
        "Duration": 1086839951,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    }
}